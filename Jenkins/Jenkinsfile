import groovy.json.JsonSlurper
import groovy.json.JsonSlurperClassic
import groovy.json.*

@NonCPS
def createBooleanParameter(String value, String desc) {
   return [$class: 'BooleanParameterDefinition', defaultValue: false, name: value, description: desc]
}
@NonCPS
def jsonParse(def json) {
    new groovy.json.JsonSlurperClassic().parseText(json)
}
pipeline {
    options {
        timeout(time: 30, unit: 'MINUTES')
    }
   
   agent { label 'master' }
    stages {
        stage ('Checkout') {
            steps {
                script {
                    deleteDir()
                    dir ('infrastructure') {
                        checkout([$class: 'GitSCM', branches: [[name: '*/master']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'git_rd_cred', url: 'https://github.com/roz-Devops/Infrastructure.git']]])
                    } 
                }
            }
        }
        stage ('Load release json') {
            steps {
                script {
                        sh 'ls'
                        sh 'pwd'
                    dir('infrastructure') {
                        sh 'ls'
                        sh 'pwd'
                        releaseFile = jsonParse(readFile("release.json"))
                        releaseName = releaseFile["release"]["name"]
                        releaseVersion = releaseFile["release"]["version"]
                        infrastructureVersion = releaseFile["release"]["infrastructure_version"]
                        automationVersion = releaseFile["release"]["automation_version"]
                        envName = releaseFile["release"]["environment"]
                        //servicesList = releaseFile["release"]["services"].keySet()
                        service_int_api = "intapi"
                        println("Those Services will be deployed ${service_int_api}")
                        print("The environment is ${envName}")
                    
                   
                    //    sh "git checkout ${infrastructureVersion}"
                        echo ("env starting")

                        environmentFile = jsonParse(readFile("environments.json"))
                        aws_region = environmentFile['environments']["${envName}"]['aws_region']
                        aws_vpc = environmentFile['environments']["${envName}"]['vpc_id']
                        subnet_prefix = environmentFile['environments']["${envName}"]['subnet_prefix']
                        security_group = environmentFile['environments']["${envName}"]['security_group']
                    }
                }
            }
        }
        stage ('Verify artifacts exist') {
        // validate artifacts in Nexus
            steps {
                script {
                        serviceVersion = releaseFile["release"]["services"]["${service_int_api}"]["version"]
                        echo (" service version is : ${serviceVersion}")
                        echo (" service service_int_api is : ${service_int_api}")
                              sh "ls /var/jenkins_home/${service_int_api}_${serviceVersion}.tar"
                              if( fileExists ("/var/jenkins_home/${service_int_api}_${serviceVersion}.tar")){
                                  println("Artifact is exists : ${service_int_api}_${serviceVersion}.tar")
                                }
                   else{    println("Artifact not exists ${service_int_api}_${serviceVersion}.tar")
                            currentBuild.result = 'FAILURE'
                        }
                    
                }
            }
        }
        stage ('Vaildate Instances amount') {
            steps {
                script {
                    dir ('infrastructure/terraform') {
                        int currentCount = sh script: "aws ec2 describe-instances --query 'Reservations[*].Instances[*].[InstanceId]' --region ${aws_region} --filters Name=instance-state-name,Values=running --output text | wc -l" , returnStdout: true
                   // int currentCount = 0
                       // sh "terraform state list"
    
                            int instance_count = releaseFile["release"]["services"]["${service_int_api}"]['instance_count']
                          //  sh "sed -i 's/REGION/${aws_region}/g' inventory.aws_ec2.yml"
                          //  int currentCount = sh script: "ansible-inventory -i inventory.aws_ec2.yml --list | grep Service_${service_int_api} | --output text | wc -l", returnStdout: true
                             echo (" currentCount : ${currentCount}")
                              echo (" instance_count : ${instance_count}")
                            int instances_to_add = instance_count - currentCount
                       sh "terraform init"
                        //    sh "terraform plan -var='envName=${envName}' -var='aws_vpc_id=${aws_vpc}' -var='securitygroup=${security_group}' -var='aws_region=${aws_region}' -var='count_var=${instances_to_add}' -var='serviceName=${service_int_api}' -var='serviceVersion=${serviceVersion}'"
                            //   sh "-backend-config=aws_region='us-east-2' terraform init"
                               
                       if ( currentCount < instance_count ) {
                          
                               echo (" instances_to_add : ${instances_to_add}")
                                 
                               //     sh "terraform validate"
                                    // sh "terraform plan"
                               sh "terraform apply -auto-approve -var='envName=${envName}' -var='aws_vpc_id=${aws_vpc}' -var='securitygroup=${security_group}' -var='aws_region=${aws_region}' -var='count_var=${instances_to_add}' -var='serviceName=${service_int_api}' -var='serviceVersion=${serviceVersion}'"
                            }
                            if ( currentCount >= instance_count ) {
                                // remove instances
                               int a =3;
                               int num_ins_to_terminate = a - instance_count
                                echo (" num_ins_to_terminate : ${num_ins_to_terminate}")
                         def running_instances = sh script: "aws ec2 describe-instances --query 'Reservations[*].Instances[*].[InstanceId]' --region ${aws_region} --filters Name=instance-state-name,Values=running --output text", returnStdout: true
                             echo (" running_instances : ${running_instances}")
                               echo "Lets reduce instances" 
                           //  sh "terraform destroy -auto-approve"
                               
                           //    instances_arr=sh script:"${running_instances//'\n'/ })"
                               
                        //      sh " read -a arr <<< $running_instances "
                               sh "arr=($running_instances) " 

                               echo (" instances_arr : ${arr}")
                               for (i in ${arr[@]}){
                                   echo (" i : $i")
                               }
                           //    for (instance_id in ${instances_arr}) {
                             //           echo (" instance_id : ${instance_id}")
                               //                echo (" instance_id[num_ins_to_terminate] : ${running_instances}[${num_ins_to_terminate}]")
                                       //    if(num_ins_to_terminate >0 && $running_instances[num_ins_to_terminate] == instance_id ){                
                                         //            sh"aws ec2 terminate-instances --instance-ids $running_instances[num_ins_to_terminate]"
                                         //            sh" num_ins_to_terminate = num_ins_to_terminate -1"
                                          //         echo (" num_ins_to_terminate after reducing : ${num_ins_to_terminate}")
                                           //           }
                                                    

                         //   }
                       
                      //      else {
                                println("[INFO] Instnaces amount are aligned")
                         //   }
                        
                    }
                }
            }
        }
        }     
        stage ('Deploy Services') {
            steps {
                script {
                    dir('infrastructure/ansible') {
                        print("ansible")

                        for ( service in service_int_api ) {
                            sh "echo [${service}] > hosts"
                            configVersion = releaseFile["release"]["services"]["${service}"]["configuration"]
                            dir('Configuration') {
                                sh "git checkout ${configVersion}"
                            }
                            sh "mkdir -p ./roles/ansible/${service}/files"
                            sh "cp ../../Configuration/${service}/*.* ./roles/${service}/files"
                            tagList = releaseFile["release"]["services"]["${service}"]["servers"]
                                // if ( ipList.isEmpty() ) {
                                //     println("This ip list is empty for ${service}")
                                //     currentBuild.result = 'FAILURE'
                                // } else {
                                //     for ( ip in ipList ) {
                                //         sh "echo ${ip} >> hosts"
                                //     }
                                sh "ansible-playbook -i hosts main.yml --extra-vars 'service=${service}'"
                                }
                        }
                    }
                }
            }
        
        stage ('Run Automation') {
            steps {
                script {
                    dir('automation') 
                    automationVersion = releaseFile["release"]["automation"]     
                    sh "git checkout ${automationVersion}"
                   
                        for ( service in service_int_api ) {
                             serverAddresses = releaseFile["release"]["services"]["${service}"]["servers"]   
                           for ( address in serverAddresses )  {   
                           sh "./sanity_tests.sh ${service} ${address}" }
                                                         }
                        }
                    }
                }
            }
    
  
}
  
