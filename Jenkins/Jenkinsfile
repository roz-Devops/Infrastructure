import groovy.json.JsonSlurper
import groovy.json.JsonSlurperClassic
@NonCPS
def createBooleanParameter(String value, String desc) {
   return [$class: 'BooleanParameterDefinition', defaultValue: false, name: value, description: desc]
}
@NonCPS
def jsonParse(def json) {
    new groovy.json.JsonSlurperClassic().parseText(json)
}
pipeline {
    options {
        timeout(time: 30, unit: 'MINUTES')
    }
    agent {
        label 'master'
    }
    stages {
        stage ('Checkout') {
            steps {
                script {
                    deleteDir()
                    dir ('infrastructure') {
                        checkout([$class: 'GitSCM', branches: [[name: '*/master']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'git_rd_cred', url: 'https://github.com/roz-Devops/Infrastructure.git']]])
                    }
                }
            }
        }
        stage ('Load release json') {
            steps {
                script {
                             sh 'ls'
                        sh 'pwd'
                    dir('infrastructure') {
                        sh 'ls'
                        sh 'pwd'
                        releaseFile = jsonParse(readFile("release.json"))
                        releaseName = releaseFile["release"]["name"]
                        releaseVersion = releaseFile["release"]["version"]
                        infrastructureVersion = releaseFile["release"]["infrastructure_version"]
                        automationVersion = releaseFile["release"]["automation_version"]
                        envName = releaseFile["release"]["environment"]
                        //servicesList = releaseFile["release"]["services"].keySet()
                        service_int_api = "intapi"
                        println("Those Services will be deployed ${service_int_api}")
                        print("The environment is ${envName}")
                    
                   
                    //    sh "git checkout ${infrastructureVersion}"
                        echo ("env starting")

                        environmentFile = jsonParse(readFile("environments.json"))
                        aws_region = environmentFile['environments']["${envName}"]['aws_region']
                        aws_vpc = environmentFile['environments']["${envName}"]['vpc_id']
                        subnet_prefix = environmentFile['environments']["${envName}"]['subnet_prefix']
                        security_group = environmentFile['environments']["${envName}"]['security_group']
                    }
                }
            }
        }
        stage ('Verify artifacts exist') {
        // validate artifacts in Nexus
            steps {
                script {
                        serviceVersion = releaseFile["release"]["services"]["${service_int_api}"]["version"]
                        echo (" service version is : ${serviceVersion}")
                        echo (" service service_int_api is : ${service_int_api}")
                              sh "ls /var/jenkins_home/${service_int_api}_${serviceVersion}.tar"
                            if( fileExists ("/var/jenkins_home/${service_int_api}_${serviceVersion}.tar")){
                              println("Artifact is exists : ${service_int_api}_${serviceVersion}.tar")

                   //     sh "ls /mnt/artifacts/dev/${service_int_api}_${serviceVersion}.tar"
                }
                   else{    println("Artifact not exists ${service_int_api}_${serviceVersion}.tar")
                            currentBuild.result = 'FAILURE'
                        }
                    
                }
            }
        }
        stage ('Vaildate Instances amount') {
            steps {
                script {
                    dir ('./terraform') {
                        int currentCount = sh script: "aws ec2 describe-instances --query 'Reservations[*].Instances[*].[InstanceId]' --region ${aws_region} --filters Name=instance-state-name,Values=running --output text | wc -l" , returnStdout: true
                 //   int currentCount = 0
                        sh "terraform init"
                        sh "terraform state list"
                        sh "terraform plan"
                            int instance_count = releaseFile["release"]["services"]["${service_int_api}"]['instance_count']
                            sh "sed -i 's/REGION/${aws_region}/g' inventory.aws_ec2.yml"
                          //  int currentCount = sh script: "ansible-inventory -i inventory.aws_ec2.yml --list | grep Service_${service_int_api} | --output text | wc -l", returnStdout: true
                             echo (" currentCount : ${currentCount}")
                              echo (" instance_count : ${instance_count}")
                            if ( currentCount < instance_count ) {
                                instances_to_add = instance_count - currentCount
                               echo (" instances_to_add : ${instances_to_add}")
                                
                                    sh "terraform validate"
                                    // sh "terraform plan"
                                 //  sh "terraform apply -auto-approve -var 'envName = ${envName}'"
                                    sh "terraform apply -auto-approve -var='envName=${envName}' -var='aws_vpc_id=${aws_vpc}' -var='securitygroup=${security_group}' -var='aws_region=${aws_region}' -var='count_var=${instances_to_add}' -var='serviceName=${service_int_api}' -var='serviceVersion=${serviceVersion}'"

                                
                            }
                            else if ( currentCount > instance_count ) {
                                // remove instances
                               echo "Lets reduce instances"
                               sh "terraform destroy -auto-approve -target='aws_instance.intapi[2]'"
                            }
                       
                            else {
                                println("[INFO] Instnaces amount are aligned")
                            }
                        
                    }
                }
            }
        }
        stage ('Deploy Services') {
            steps {
                script {
                    dir('infrastructure/ansible') {
                        for ( service in service_int_api ) {
                            sh "echo [${service}] > hosts"
                            configVersion = releaseFile["release"]["services"]["${service}"]["configuration"]
                            dir('Configuration') {
                                sh "git checkout ${configVersion}"
                            }
                            sh "mkdir -p ./roles/ansible/${service}/files"
                            sh "cp ../../Configuration/${service}/*.* ./roles/${service}/files"
                            tagList = releaseFile["release"]["services"]["${service}"]["servers"]
                                // if ( ipList.isEmpty() ) {
                                //     println("This ip list is empty for ${service}")
                                //     currentBuild.result = 'FAILURE'
                                // } else {
                                //     for ( ip in ipList ) {
                                //         sh "echo ${ip} >> hosts"
                                //     }
                                sh "ansible-playbook -i hosts main.yml --extra-vars 'service=${service}'"
                                }
                        }
                    }
                }
            }
        
        stage ('Run Automation') {
            steps {
                script {
                    dir('automation') 
                    automationVersion = releaseFile["release"]["automation"]     
                    sh "git checkout ${automationVersion}"
                   
                        for ( service in service_int_api ) {
                             serverAddresses = releaseFile["release"]["services"]["${service}"]["servers"]   
                           for ( address in serverAddresses )  {   
                           sh "./sanity_tests.sh ${service} ${address}" }
                                                         }
                        }
                    }
                }
            }
    
  
}
  
